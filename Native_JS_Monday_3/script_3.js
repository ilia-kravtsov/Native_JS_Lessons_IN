/*

1 термин
    Обработчик === Handler === Listener === Subscriber === это все функция function которая ожидает некоего события
2 термин
    handler является подмножеством ⊂ callback

callback не вызывается нами, он вызывается другой сущностью (управляющим кодом) тогда когда ему будет нужно
с этой точки зрения все обработчики событий являются callback
то есть это функции которые вызываются каким-то управляющим кодом (кнопкой, браузером в результате клика на кнопку)
тогда когда управляющий код сочтет это необходимым

Понятие handler это одна из разновидностей callback

Использование callback

callback => handler, setTimeout/setInterval, и еще когда мы используем ее в param of arrays methods

мы делаем запрос на сервер и если сервер ответил мы выполняем функцию - это тоже callback (функция)

onclick = handler; по клику будет вызываться функция handler({...}) => alert('yo')
Вне зависимости от того используем мы в теле функции event или не используем, он туда передается в виде объекта
если не передаем в виде пустого {...} если используем тогда уже с тем параметром который мы передаем {event}

Всегда при вызове функции браузер будет передавать в качестве первого параметра некий объект handler({...})
Этот объект мы называем event

{...} - event, ev, e - это объект
Этот объект для нас ценен тем что он содержит в себе различные сведения о произошедшем событии (данные о событии)
То есть в этом объекте в порядке ключ значение - находятся все сведения о произошедшем событии, с одной стороны это
объект который описывает событие.
События могут быть разными onClick onKeyPress onChange onBlur под каждое событие свои свойства, но наследуется
event от родового объекта Event

Для каждого события есть свой список сведений которые в нем представлены

как нам повесить обработчик или подписаться на событие

в native JS есть 2 способа это сделать

const sm = document.getElementById('small')  - мы получили ссылку на объект который лежит в DOM дереве

Создаем обработчик

const handler = (e) => {
    console.log(e) // PointerEvent {isTrusted: true, pointerId: 1, width: 1, height: 1, pressure: 0, …}
}                     PoniterEvent - это событие которое произошло в результате действия указателя

event => PointerEvent => MouseEvent => UIEvent => Event => Object
у всех объектов Event есть свойства currentTarget target preventDefault stopPropagation composedPath

sm.onclick - у каждого объекта есть свойство onclick когда на нем происходит событие браузер проверяет
наличие функции в этом свойстве если функция есть то она будет вызвана
в момент вызове ей будет передан объект event

sm.onclick = handler

cнимаем обработчик

sm.onclick = null либо '' - после этого реакции на событие не происходит

Если

const handler1 = (e) => {
    console.log(e)
}

const handler2 = (e) => {
    console.log(e)
}

sm.onclick = handler1
sm.onclick = handler2   -   handler 2 затрет handler1
потому что свойство может иметь только 1 значение
любая попытка присвоить свойству новое значение приводит к тому что прежнее значение мы теряем
это и есть основная причина по которой назначение обработчика с помощью атрибута onclick считается устаревшим

Сегодня обработчики нужно добавлять через метод элементов

sm.addEventListener() - добавить слушателя ивента

addEventListener() - это функция (метод всех html элементов, метод объекта) которая принимает 2 основных параметра

1 параметр тип события и второй это функция которую мы хотим использовать в качестве обработчика события

sm.addEventListener('click', handler1)

преимущества

sm.addEventListener('click', handler1) по клику будет и алерт и консоль
sm.addEventListener('click', handler2) handler1 и handler2 вызываются независимо друг от друга

в то что формируется массив функций, в onclick попадает функция внутри которой лежит массив функций которые будут
вызваны при наступлении события, внутри нее есть цикл for по которому функция пробегает и вызывает функции из
этого массива а функция addEventListener либо добавляет эти функции в массив либо удаляет эти функции из массива

снимаем addEventListener

sm.removeEventListener('click', handler1)

меняем
sm.addEventListener('click', handler2)
на
sm.addEventListener('click', (e) => alert(e))

и пытаемся так же удалить

sm.removeEventListener('click', (e) => alert(e)) алерт все равно срабатывает потому что речь будет идти
о двух разных функциях

Поэтому при назначении обработчика с помощью метода addEventListener мы практически никогда стараемся не использовать
анонимные функции а всегда используем именованные функции
в таком случае

sm.addEventListener('click', handler1)
sm.addEventListener('click', handler2)

sm.removeEventListener('click', handler1)
sm.removeEventListener('click', handler2)

обе функции снимутся и ни алерт ни консоль не будут работать

Когда элементы (div) наложены друг на друга при этом имеют разный размер и мы хотим на каждый прикрепить событие клика
то возникает вопрос по какому именно элементу совершается клик

2 концепции

Стадия погружения - тоннель 1 %
Допустим первоначально событие произошло в элементе body потом переместилась в дивку middle а потом произошло на кнопке
body => middle div => button

Cтадия всплытия - пирамидка в большинстве случаев мы будем рассматривать событие как всплывающее 99 %
Первоначальное событие происходит по кнопке потом в div middle потом в body
button => middle div => body

Всплывающее событие - это событие которое произошло в самом наружном элементе а потом событие продолжило движение
событие не умирает на кнопке оно продолжает двигаться дальше, если эта кнопка лежала в div значит в этой div происходит
событие onclick событие всплывает дальше и т.д.
То есть событие клик является всплывающим - задействует все родительские элементы того элемента который поймал клик

const sm = document.getElementById('small')
const md = document.getElementById('middle')
const bg = document.getElementById('big')

sm.onclick = handler1
md.onclick = handler1
bg.onclick = handler1

таким образом после клика по sm видим сразу 3 console.log(e) в консоли
таким образом мы убедились что событие последовательно всплывает

если мы заглянем в объект событие, то нам будет интересно свойство event path
там будет отображен путь всплытия

Всплытие
small => middle => big => body => html => document => window

Для нас появляются элементы двух типов

элемент где событие родилось, - он всегда будет записан в объекте событие в свойстве target => e.target
и он никогда не изменится по ходу жизни события
это как место рождения

а как место фактического проживания или
как место текущее место нахождения события - записывается в свойство e.currentTarget

после клика
target: div#small
currentTarget: null - потому что событие происходит очень быстро и к моменту пока мы на него посмотрим уже дойдет до
window и умрет

чтобы поймать событие скажем handler console.log(e.currentTarget) таким образом поймаем значение currentTarget
в момент выполнения
console.dir(e.currentTarget) div#small

Если структура проекта не имеет наложения элементов и не будет меняться
то можно использовать target
то есть обрабатывать событие через e.target потому что чаще всего когда мы вешаем обработчик события на элемент
по которому пользователь кликает то чаще всего имеется ввиду что по этому элементу пользователь и должен тыкнуть

Если это кнопка и я на эту кнопку вешаю обработчик события и если надо как-то к этой кнопке обратиться я пишу
e.target беру id или name у этой кнопки и дальше с ним работаю

Но в целом ряде случаев мы можем столкнутся с такой ситуацией
Когда пользователь кликнет по маленькой div

sm.onclick = handler1

const handler1 = (e) => {
    if (e.target.id === 'small') {
        alert('ОК') - выводит алерт при клике на small
    }
}

Допустим кто-то добавил дочерний элемент к тому на котором происходит событие клик
после этого событие не будет консолиться потому что не будет совпадать id того элемента по которому кликают и того
который мы прописали в функции

Т.о. если мы будем использовать событие target в ситуации когда у нас не стабильная структура html или когда может
появиться какой-либо вложенный элемент то событие работать не будет

Но если мы напишем currentTarget то сработает в любом случае

const handler1 = (e) => {
    if (e.currentTarget.id === 'small') {
        alert('ОК')
    }
}

Зачем тогда нужен target

Допустим у нас в html в div small 5 кнопок button

<div id="small" class>
        <button id="1">1</button>
        <button id="2">2</button>
        <button id="3">3</button>
        <button id="4">4</button>
        <button id="5">5</button>
</div>

и нам надо посмотреть по какой кнопке кликнули и взависимости от того по какой кнопке кликнули мы будем что-то делать

Создание новой функции регистрация обработчика поддержание этой связи достаточно затратно для браузера
будет требовать больше оперативной памяти

Поэтому повесить 1000 функций обработчиков событий это плохая идея, поэтому

Есть такой прием который называется делигирование обработки события родительскому элементу
у меня 5 кнопок но я не буду вешать 5 функций обработчиков и 1000 не буду вешать

я на родительский элемент small повешу какую-то функцию, но мне нужно вызывать ее только если пользователь кликает
по кнопке
Значит мне нужно проверить куда пользователь кликнул по какой кнопке или по small
и здесь используется свойство target

const handler1 = (e) => {
    if (e.target.tagName === 'button') {
        alert(e.target.id)
    } - если кликнули по кнопке то я могу в дальнейшем использовать id этой кнопки
}

фишка в том что теперь у меня 1 обработчик события для всех элементов

Когда кликаю по кнопке выводится id кнопки а когда кликаю на элемент то ничего не выводится
т.о. я могу добавлять и удалять кнопки не изменяя функцию обработчик
1 функция обрабатывает неограниченное количество функций

Такой подход в реакте не любят потому что тогда в компоненту не передается функция callback
Но такой подход быстрее

const handler1 = (e) => {
    if (e.target.tagName === 'BUTTON') {
        alert(e.target.id)
    }
}

const handler2 = (e) => {
    alert(e)
}

const handler3 = (e) => {

}

sm.onclick = handler1
md.onclick = handler2
bg.onclick = handler3

По клику на каждый элемент я должен получить соответствующую реакцию

по клику на кнопку выводим id кнопки на которую нажали а за ней появляется алерт с событием из middle
потому что его event высплыл

поэтому по умолчанию будем использовать currentTarget
this - это currentTarget тождественно равны, и то и то тот элемент который вызывает функцию
не тот по которому ткнули а тот который вызывает функцию хотя они совпадают

в объекте событие есть такая функция метод stopPropagation

    e.stopPropagation() e.Прекращение распространения()\

Это функция, которая является методом объекта event прекращает всплытие события
Таким образом если пользователь кликнет по small то никаких больше alert мы не увидим

target currentTarget - это про дочерние элементы работает вниз по дереву
stopPropagation - для изоляции родительского элемента работает вверх по дереву

________________________________________________________________________________________________________________________

У нас есть элементы которые имеют при клике свое собственное поведение по умолчанию
(без прописанного нами обработчика события)
это
ссылки кнопки внутри формы с типом submit

Мы не хотим чтобы ссылка вела себя так как ей написано вести себя по умолчанию
для этого используем  e.preventDefault() - предотвратить поведение по умолчанию
с этого момента ссылка перестанет нас перенаправлять на другой сайт

const handler4 = (e) => {
    e.preventDefault()
    alert('привет')
}

const a = document.getElementById('a')

a.addEventListener('click', handler4)

теперь после нажатия по ссылке видим alert(привет)

в зависимости от типа события в зависимости от целей и задач объекты события у нас будут разные
события клавиатуры - не всплывают onBlur OnChange - они не всплывают
клик всплывает

Когда событие всплывает по DOM дереву появляется понятие currentTarget то есть текущий элемент
не тот элемент который его породил, не место рождения

И поэтому мы использовали target и stopPropagation чтобы всплытие дальше не шло

чаще всего почему я использую currentTarget внутри функции обработчика потому что чаще всего
меня интересует взаимодействие именно с тем элементом на который я эту функцию повесил
не по тому по которому кликнут
я хочу взаимодействовать с тем элементом на который повесил функцию обработчик наиболее полно
это решается с помощью currentTarget

target - тоже можно использовать если код простой то что target что currentTarget они работают одинаково

В свойстве currentTarget будет лежать именно тот элемент который вызвал функцию а не тот по которому кликнули
хотя они часто совпадают
это как let и const

currentTarget гарантированно дает тебе ссылку на тот элемент который вызвал функцию обработчик
target не гарантировано тебе дает ссылку на функцию обработчик потому что вдруг там в родительском элементе кнопки
была картинка или div c display: none

принципиально сокращаю количество печатных символов для интерпретатора моей программы чтобы сократить расходы
электроэнергии
*/
const sm = document.getElementById('small')
const md = document.getElementById('middle')
const bg = document.getElementById('big')

const handler1 = (e) => {

    e.stopPropagation()

    if (e.target.tagName === 'BUTTON') {
        alert(e.target.id)
    }
}

const handler2 = (e) => {
    alert(e)
}

const handler3 = (e) => {
    alert('yo')
}

const handler4 = (e) => {
    e.preventDefault()
    alert('привет')
}

// sm.onclick = handler
// sm.onclick = null

sm.addEventListener('click', handler1)
sm.addEventListener('click', handler2)

sm.removeEventListener('click', handler1)
sm.removeEventListener('click', handler2)

sm.onclick = handler1
md.onclick = handler2
bg.onclick = handler3


const a = document.getElementById('a')

a.addEventListener('click', handler4)























