/*

1 термин
    Обработчик === Handler === Listener === Subscriber === это все функция function которая ожидает некоего события
2 термин
    handler является подмножеством ⊂ callback

callback не вызывается нами, он вызывается другой сущностью (управляющим кодом) тогда когда ему будет нужно
с этой точки зрения все обработчики событий являются callback
то есть это функции которые вызываются каким-то управляющим кодом (кнопкой, браузером в результате клика на кнопку)
тогда когда управляющий код сочтет это необходимым

Понятие handler это одна из разновидностей callback

Использование callback

callback => handler, setTimeout/setInterval, и еще когда мы используем ее в param of arrays methods

мы делаем запрос на сервер и если сервер ответил мы выполняем функцию - это тоже callback (функция)

onclick = handler; по клику будет вызываться функция handler({...}) => alert('yo')
Вне зависимости от того используем мы в теле функции event или не используем, он туда передается в виде объекта
если не передаем в виде пустого {...} если используем тогда уже с тем параметром который мы передаем {event}

Всегда при вызове функции браузер будет передавать в качестве первого параметра некий объект handler({...})
Этот объект мы называем event

{...} - event, ev, e - это объект
Этот объект для нас ценен тем что он содержит в себе различные сведения о произошедшем событии (данные о событии)
То есть в этом объекте в порядке ключ значение - находятся все сведения о произошедшем событии, с одной стороны это
объект который описывает событие.
События могут быть разными onClick onKeyPress onChange onBlur под каждое событие свои свойства, но наследуется
event от родового объекта Event

Для каждого события есть свой список сведений которые в нем представлены

как нам повесить обработчик или подписаться на событие

в native JS есть 2 способа это сделать

const sm = document.getElementById('small')  - мы получили ссылку на объект который лежит в DOM дереве

Создаем обработчик

const handler = (e) => {
    console.log(e) // PointerEvent {isTrusted: true, pointerId: 1, width: 1, height: 1, pressure: 0, …}
}                     PoniterEvent - это событие которое произошло в результате действия указателя

event => PointerEvent => MouseEvent => UIEvent => Event => Object
у всех объектов Event есть свойства currentTarget target preventDefault stopPropagation composedPath

sm.onclick - у каждого объекта есть свойство onclick когда на нем происходит событие браузер проверяет
наличие функции в этом свойстве если функция есть то она будет вызвана
в момент вызове ей будет передан объект event

sm.onclick = handler

cнимаем обработчик

sm.onclick = null либо '' - после этого реакции на событие не происходит

Если

const handler1 = (e) => {
    console.log(e)
}

const handler2 = (e) => {
    console.log(e)
}

sm.onclick = handler1
sm.onclick = handler2   -   handler 2 затрет handler1
потому что свойство может иметь только 1 значение
любая попытка присвоить свойству новое значение приводит к тому что прежнее значение мы теряем
это и есть основная причина по которой назначение обработчика с помощью атрибута onclick считается устаревшим

Сегодня обработчики нужно добавлять через метод элементов

sm.addEventListener() - добавить слушателя ивента

addEventListener() - это функция (метод всех html элементов, метод объекта) которая принимает 2 основных параметра

1 параметр тип события и второй это функция которую мы хотим использовать в качестве обработчика события

sm.addEventListener('click', handler1)

преимущества

sm.addEventListener('click', handler1) по клику будет и алерт и консоль
sm.addEventListener('click', handler2) handler1 и handler2 вызываются независимо друг от друга

в то что формируется массив функций, в onclick попадает функция внутри которой лежит массив функций которые будут
вызваны при наступлении события, внутри нее есть цикл for по которому функция пробегает и вызывает функции из
этого массива а функция addEventListener либо добавляет эти функции в массив либо удаляет эти функции из массива

снимаем addEventListener

sm.removeEventListener('click', handler1)

меняем
sm.addEventListener('click', handler2)
на
sm.addEventListener('click', (e) => alert(e))

и пытаемся так же удалить

sm.removeEventListener('click', (e) => alert(e)) алерт все равно срабатывает потому что речь будет идти
о двух разных функциях

Поэтому при назначении обработчика с помощью метода addEventListener мы практически никогда стараемся не использовать
анонимные функции а всегда используем именованные функции
в таком случае

sm.addEventListener('click', handler1)
sm.addEventListener('click', handler2)

sm.removeEventListener('click', handler1)
sm.removeEventListener('click', handler2)

обе функции снимутся и ни алерт ни консоль не будут работать

Когда элементы (div) наложены друг на друга при этом имеют разный размер и мы хотим на каждый прикрепить событие клика
то возникает вопрос по какому именно элементу совершается клик

2 концепции

Стадия погружения - тоннель 1 %
Допустим первоначально событие произошло в элементе body потом переместилась в дивку middle а потом произошло на кнопке
body => middle div => button

Cтадия всплытия - пирамидка в большинстве случаев мы будем рассматривать событие как всплывающее 99 %
Первоначальное событие происходит по кнопке потом в div middle потом в body
button => middle div => body

Всплывающее событие - это событие которое произошло в самом наружном элементе а потом событие продолжило движение
событие не умирает на кнопке оно продолжает двигаться дальше, если эта кнопка лежала в div значит в этой div происходит
событие onclick событие всплывает дальше и т.д.
То есть событие клик является всплывающим - задействует все родительские элементы того элемента который поймал клик

const sm = document.getElementById('small')
const md = document.getElementById('middle')
const bg = document.getElementById('big')

sm.onclick = handler1
md.onclick = handler1
bg.onclick = handler1

таким образом после клика по sm видим сразу 3 console.log(e) в консоли
таким образом мы убедились что событие последовательно всплывает

если мы заглянем в объект событие, то нам будет интересно свойство event path
там будет отображен путь всплытия

Всплытие
small => middle => big => body => html => document => window

Для нас появляются элементы двух типов

элемент где событие родилось, - он всегда будет записан в объекте событие в свойстве target => e.target
и он никогда не изменится по ходу жизни события
это как место рождения

а как место фактического проживания или
как место текущее место нахождения события - записывается в свойство e.currentTarget

после клика
target: div#small
currentTarget: null - потому что событие происходит очень быстро и к моменту пока мы на него посмотрим уже дойдет до
window и умрет

чтобы поймать событие скажем handler console.log(e.currentTarget) таким образом поймаем значение currentTarget
в момент выполнения
console.dir(e.currentTarget) div#small

Если структура проекта не имеет наложения элементов и не будет меняться
то можно использовать target
то есть обрабатывать событие через e.target потому что чаще всего когда мы вешаем обработчик события на элемент
по которому пользователь кликает то чаще всего имеется ввиду что по этому элементу пользователь и должен тыкнуть

Если это кнопка и я на эту кнопку вешаю обработчик события и если надо как-то к этой кнопке обратиться я пишу
e.target беру id или name у этой кнопки и дальше с ним работаю

Но в целом ряде случаев мы можем столкнутся с такой ситуацией
Когда пользователь кликнет по маленькой div

sm.onclick = handler1

const handler1 = (e) => {
    if (e.target.id === 'small') {
        alert('ОК') - выводит алерт при клике на small
    }
}

Допустим кто-то добавил дочерний элемент к тому на котором происходит событие клик
после этого событие не будет консолиться потому что не будет совпадать id того элемента по которому кликают и того
который мы прописали в функции

Т.о. если мы будем использовать событие target в ситуации когда у нас не стабильная структура html или когда может
появиться какой-либо вложенный элемент то событие работать не будет

Но если мы напишем currentTarget то сработает в любом случае

const handler1 = (e) => {
    if (e.currentTarget.id === 'small') {
        alert('ОК')
    }
}

Зачем тогда нужен target

Допустим у нас в html в div small 5 кнопок button

<div id="small" class>
        <button id="1">1</button>
        <button id="2">2</button>
        <button id="3">3</button>
        <button id="4">4</button>
        <button id="5">5</button>
</div>

и нам надо посмотреть по какой кнопке кликнули и взависимости от того по какой кнопке кликнули мы будем что-то делать

Создание новой функции регистрация обработчика поддержание этой связи достаточно затратно для браузера
будет требовать больше оперативной памяти

Поэтому повесить 1000 функций обработчиков событий это плохая идея, поэтому

Есть такой прием который называется делигирование обработки события родительскому элементу
у меня 5 кнопок но я не буду вешать 5 функций обработчиков и 1000 не буду вешать

я на родительский элемент small повешу какую-то функцию, но мне нужно вызывать ее только если пользователь кликает
по кнопке
Значит мне нужно проверить куда пользователь кликнул по какой кнопке или по small
и здесь используется свойство target

const handler1 = (e) => {
    if (e.target.tagName === 'button') {
        alert(e.target.id)
    } - если кликнули по кнопке то я могу в дальнейшем использовать id этой кнопки
}

фишка в том что теперь у меня 1 обработчик события для всех элементов

Когда кликаю по кнопке выводится id кнопки а когда кликаю на элемент то ничего не выводится
т.о. я могу добавлять и удалять кнопки не изменяя функцию обработчик
1 функция обрабатывает неограниченное количество функций

Такой подход в реакте не любят потому что тогда в компоненту не передается функция callback
Но такой подход быстрее

const handler1 = (e) => {
    if (e.target.tagName === 'BUTTON') {
        alert(e.target.id)
    }
}

const handler2 = (e) => {
    alert(e)
}

const handler3 = (e) => {

}

sm.onclick = handler1
md.onclick = handler2
bg.onclick = handler3

По клику на каждый элемент я должен получить соответствующую реакцию

по клику на кнопку выводим id кнопки на которую нажали а за ней появляется алерт с событием из middle
потому что его event высплыл

поэтому по умолчанию будем использовать currentTarget
this - это currentTarget тождественно равны, и то и то тот элемент который вызывает функцию
не тот по которому ткнули а тот который вызывает функцию хотя они совпадают

в объекте событие есть такая функция метод stopPropagation

    e.stopPropagation() e.Прекращение распространения()\

Это функция, которая является методом объекта event прекращает всплытие события
Таким образом если пользователь кликнет по small то никаких больше alert мы не увидим

target currentTarget - это про дочерние элементы работает вниз по дереву
stopPropagation - для изоляции родительского элемента работает вверх по дереву

________________________________________________________________________________________________________________________

У нас есть элементы которые имеют при клике свое собственное поведение по умолчанию
(без прописанного нами обработчика события)
это
ссылки кнопки внутри формы с типом submit

Мы не хотим чтобы ссылка вела себя так как ей написано вести себя по умолчанию
для этого используем  e.preventDefault() - предотвратить поведение по умолчанию
с этого момента ссылка перестанет нас перенаправлять на другой сайт

const handler4 = (e) => {
    e.preventDefault()
    alert('привет')
}

const a = document.getElementById('a')

a.addEventListener('click', handler4)

теперь после нажатия по ссылке видим alert(привет)

в зависимости от типа события в зависимости от целей и задач объекты события у нас будут разные
события клавиатуры - не всплывают onBlur OnChange - они не всплывают
клик всплывает

Когда событие всплывает по DOM дереву появляется понятие currentTarget то есть текущий элемент
не тот элемент который его породил, не место рождения

И поэтому мы использовали target и stopPropagation чтобы всплытие дальше не шло

чаще всего почему я использую currentTarget внутри функции обработчика потому что чаще всего
меня интересует взаимодействие именно с тем элементом на который я эту функцию повесил
не по тому по которому кликнут
я хочу взаимодействовать с тем элементом на который повесил функцию обработчик наиболее полно
это решается с помощью currentTarget

target - тоже можно использовать если код простой то что target что currentTarget они работают одинаково

В свойстве currentTarget будет лежать именно тот элемент который вызвал функцию а не тот по которому кликнули
хотя они часто совпадают
это как let и const

currentTarget гарантированно дает тебе ссылку на тот элемент который вызвал функцию обработчик
target не гарантировано тебе дает ссылку на функцию обработчик потому что вдруг там в родительском элементе кнопки
была картинка или div c display: none

принципиально сокращаю количество печатных символов для интерпретатора моей программы чтобы сократить расходы
электроэнергии
*/
const sm = document.getElementById('small')
const md = document.getElementById('middle')
const bg = document.getElementById('big')

const handler1 = (e) => {

    e.stopPropagation()

    if (e.target.tagName === 'BUTTON') {
        alert(e.target.id)
    }
}

const handler2 = (e) => {
    alert(e)
}

const handler3 = (e) => {
    alert('yo')
}

const handler4 = (e) => {
    e.preventDefault()
    alert('привет')
}

// sm.onclick = handler
// sm.onclick = null

sm.addEventListener('click', handler1)
sm.addEventListener('click', handler2)

sm.removeEventListener('click', handler1)
sm.removeEventListener('click', handler2)

sm.onclick = handler1
md.onclick = handler2
bg.onclick = handler3


const a = document.getElementById('a')

a.addEventListener('click', handler4)


/*
new Version

// _________________________________________ обработка событий в браузере

/*
событие в браузере это некий триггер для браузера потому что браузер отслеживает события,
так как браузер события отслеживает мы можем определить последовательность действий браузера при наступлении событий,
то есть обработать наступившее событие, создать подписчика на конкретное событие
то есть обработка подписка прослушивание это функция которая отслеживает данное событие
в этой функции мы говорим что надо делать браузеру при наступлении этого события
мы ассоциируем наступление события с вызовом функции обработчика или подписчика или слушателя

при наступлении события в браузере мы можем определить действие которое описываем внутри функции
которое необходимо выполнить браузеру при наступлении определенного события

у нас есть несколько конструкций которые позволяют создать эту связку
элемент событие и функция которая будет выполнена при наступлении определенного события на элементе
пример:
    если произошел клик по кнопке происходит alert

обработчик слушатель подписчик это функция которая будет выполняться при наступлении ассоциированного с ней
события

помимо того что браузере может начать выполнять эту функцию при наступлении события браузер создает объект:
new Event()
с помощью функции конструктора Event

то есть некие изменения в состоянии браузера (которые происходят в браузере)
и которые браузер в состоянии отслеживать и как то на них реагировать

эти изменения могут быть связаны с:
    действиями пользователя (клик hover)
    события документа или сетевые события (подгрузка данных, документ загрузился, браузер в онлайн или в офлайн)
 */

/*
Создание сложных сущностей в языке JS
Есть специальные функции конструкторы
но поскольку функция является объектом то иногда их называют глобальный объект
пример:
    Array - это функция потому что чаще всего мы будем использовать ее как функцию
    new Array() после такого на выходе мы получим массив []
    но иногда мы используем эту функцию как объект:
    пример:
        Array.isArray()
        const array = new Array() || []
        литерал из сложных типов есть только у массивов и объектов
        остальные сложные сущности создаются с помощью new Some() как new Array()
        то есть с помощью вызова функции конструктора
        new Array() - создай новый массив
точно так же браузер вызывает функцию конструктор new Event()
и в этом случае будет сгенерирован объект события new Event() => {}

функции конструкторы применяются для создания типовых сложных объектов
вызови нужную тебе функцию получишь нужную тебе сущность
единственное отличие от обычных функций в том что функции конструкторы могут называть глобальными объектами или классами
здесь нет противоречия потому что функция в JS это объект

Array.isArray([1,2,3]) true
Array.isArray({'some': 'some'}) false

метод isArray написали потому что определить массив с помощью typeof сложно потому что
на массив оператор typeof дает ответ object

console.log(typeof []) => object

то есть иногда мы используем Array как функцию конструктор в new Array() а иногда как объект с методом Array.isArray()
поэтому его и называют и глобальный объект и функция конструктор

функция конструктор вызывается для создания объекта типового вида

___________________________________________________________________

в результате наступления каждого события в браузере создается объект
который основан на интерфейсе Event то есть создается с помощью функции конструктора Event
при этом в зависимости от того при наступлении какого события сгенерирован данный объект Event
он может иметь дополнительные поля или функции позволяющие получить дополнительную или спецефическую информацию о том
что произошло

наступает событие
браузер формирует стандартный типовой объект new Event() => {} (в коде этот объект чаще всего называют event или е)
event || e - это объект который создан с помощью класса new Event()
соответственно это специальная функция и все поля какие значения которые у него будет уже запротоколированы
дальше браузер проверяет есть ли функция
дальше при наступлении события браузер будет вызывать нашу функцию обработчик события (onClick(() => {}))
и всегда в каждом случае будет передавать в эту функцию в момент вызова функции обработчика
в качестве параметра наш объект event (onClick((event) => {}))

и соответственно внутри функции мы можем получить все сведения о произошеднем событии event
сколько длилось милисекунд на каком элементе появилось координаты и т.д.
всё что нам нужно знать о событии упаковывается в объект event

console.log(typeof []) // object



function handler(xxx) {
    console.log(xxx)
 }

const button = document.getElementById('small') - нахождение элемента в DOM

button.onClick = handler - регистрация функции обработчика на дом элементе которая будет вызвана в момент
наступления события onClick на элементе

допускается передача переменной которая содержит ссылку на функцию
button.onClick = handler

либо передача самой функции в переменную
button.onClick = function handler(xxx) {
    console.log(xxx)
 }

в том числе анонимной
button.onClick = function (xxx) {
    console.log(xxx)
 }

она может быть стрелочной а может быть регулярной от function

onClick={handler} - как правило так
onClick={handler()} такой код может быть рабочим только в том случае если handler вернет новую функцию

button.onClick = handler
button.onClick = handle2 - функция перезатирается
button.onClick = null - удаляем обработчик

добавление нескольких обработчиков на один элемент

button.addEventListener('click',handler)
button.addEventListener('click',handler2)

button.removeEventListener('click', handler) - исключаем функцию handler из числа обработчиков

нюанс addEventListener в том что если в качестве обработчика использовать анонимную функцию
button.addEventListener('click',() => {}))
то возникнут проблемы с отменой данной функции через removeEventListener

обработчики вызываются в порядке назначения несмотря на то с помощью какой конструкции они назначены
button.onClick = handler
button.addEventListener('click',handler)

в консоли
getEventListeners(document.getElementById('small'))
выдаст объект с типом события и массивом функций обрабатывающих данное событие
со всеми обработчиками событий на элементе с id small

_______________________________________________Всплытие событий

button => div => body - bubbling всплытие - основная модель поведения при рассмотрении события
по умолчанию браузер рассматривает модель обработки событий именно как всплывающее
body => div => button - capture погружение

всплытие будет продолжаться от кнопки до document
 */

const small = document.getElementById('small')
const medium = document.getElementById('medium')
const big = document.getElementById('big')

function handler_1 () {
    alert('1')
}

function handler_2 () {
    alert('2')
}

function handler_3 () {
    alert('3')
}

small.onclick = handler_1
medium.onclick = handler_2
big.onclick = handler_3

// при клике по small событие всплывает до small к big видим последовательное появление 1 2 3

// третий параметр addEventListener options?: boolean | AddEventListener
// позволяет контролировать событие например чтобы оно сработало только 1 раз
// если передать в options true то изменится порядок срабатывания обработчиков с 1 2 3 на 3 2 1
// то есть вместо всплытия будет capture погружение
small.addEventListener('click', handler_1, true)
medium.addEventListener('click', handler_2, true)
big.addEventListener('click', handler_3, true)

// сначала погружение потом всплытие
// первоначально отрабатывается модель погружения 3 1 потом идет всплытие события 2 итого 3 1 2
small.addEventListener('click', handler_1, true)
medium.addEventListener('click', handler_2, false)
big.addEventListener('click', handler_3, true)

// как правильно назначать обработчики событий на document или на window ответ document

// есть элемент на котором произошел клик а есть элемент на котором произошел вызов функции обработчика
// они могут быть разными так как обработчик может находиться на родительском элементе
// но не находиться на дочернем

// так вот элемент на котором произошел клик называется event.target
// то есть элемент с которого все началось целевой элемент

// соответственно элементы которые вызвали функцию обработчик записывается в свойство объекта event
// event.currentTarget

// элементов которые могут вызывать функции обработчики e.currentTarget у нас несколько

// currentTarget и target может быть одним и тем же элементом
// чаще всего внутри функции мы хотим взаимодействовать именно с тем элементом который вызывает нашу функцию
// для этого лучше всего использовать свойство currentTarget
// потому что если структура html элементов простая то currentTarget and target will be the same
// но если структура более сложная то может возникнуть конфликт

// target это привязка к конкретному элементу
// currentTarget где бы не кликнул пользователь если событие доплывет до нашего элемента
// то вызови функцию обработчик
// то есть я привязываюсь к элементу на котором висит обработчик а не к тому на который кликнули
// в самом простом случае свойства target and currentTarget will give the link on the same object
// даже для не всплывающих событий

// свойство this и currentTarget совпадают
// this это то что вызывает нашу функцию
// currentTarget это тот элемент который породил событие которое в последующем может привести к вызову обработчика

/*
как предотвратить всплытие
в объекте событие есть метод e.stopPropagation()

e.stopPropagation() предотвращает всплытие к родительскому элементу
это означает остановку передачи события от компонента-потомка к компоненту-родителю.

function handler_1 () {
    e.stopPropagation() - после того как вызовут эту функцию больше это событие дальше не распространять
    alert('1')
} // cancelBubble

e.stopImmediatePropagation() используется когда с помощью addEventListener вешаются несколько
функций обработчиков
и если мы хотим чтобы сработала только одна из них то e.stopImmediatePropagation()


Применение e.stopPropagation() само по себе не вызывает значительного снижения производительности React приложения.
Однако, использование этого метода может повлиять на некоторые аспекты производительности в следующих случаях:

Сложность компонентов: Если ваше приложение содержит множество вложенных компонентов с обработчиками событий
и применением e.stopPropagation(), это может привести к сложности в управлении потоком событий и усложнению кода.
Это может затруднить отладку и поддержку приложения.

Перерисовка компонентов: Если компоненты в приложении перерисовываются часто, использование e.stopPropagation()
может привести к необходимости выполнения дополнительной работы в React для обновления компонентов.
Это может незначительно повлиять на производительность в случае большого количества компонентов или частых обновлений.

e.preventDefault() - отменяет стандартное поведение элемента

function handler_1 () {
    console.log(this === e.currentTarget) true элемент который вызывает функцию обработчик это одно и тоже <div>
    e.stopPropagation()
    alert('1')
}

const handler_1 = () => {
    console.log(this) window
    e.stopPropagation()
    alert('1')
} this в стрелочной функции это всегда глобальный объект window
*/














