// function outerFunction(x) {
//     return function innerFunction(y, z) {
//         return x + y + z
//     }
// }
//
// const add5 = outerFunction(5)
// // add5(3) = function innerFunction(y) {
// //     return 5 + y
// // }
// console.log(add5(3, 6)) // 8
// _____________________________________________________________________________________________________________________
// let car;
// car = 'bmv'
//
// function startCarEnging() {
//     let enging = 'Start';
//     return () => {
//         console.log(`${enging} ${car}`)
//     };
// }
//
// startCarEnging()()
// _____________________________________________________________________________________________________________________
// function startCarEnging() {
//     let enging = 'Start';
//     return () => {
//         console.log(`${enging} ${car}`)
//     };
// }
//
// const drive = startCarEnging();
// drive();
// _________________________Пример для замыкания________________________________________________________________________
//
// const counter = () => {
//     let count = 1
//     return () => {
//         console.log(count++)
//     }
// }
//
// counter()




// _____________________________________________________________________________________________________________________

// const createCounter = () => {
//     let count = 1;
//     return {
//         increment() {
//             count++
//         },
//         getCounter() {
//             return count
//         }
//     }
// }
//
// const counter1 = createCounter()
//
// counter1.increment()
//
// console.log(counter1.getCounter()) // 2 почему ?

// _____________________________________________________________________________________________________________________

// const createCounter = () => {
//     let count = 1;
//     return {
//         increment() {
//             count++
//         },
//         getCounter() {
//             return count
//         }
//     }
// }
//
// const counter1 = createCounter()
//
// counter1.increment()
// console.log('----')
// console.log(counter1.getCounter()) // 11

// _____________________________________________________________________________________________________________________

// const counter = () => {
//     let count = 1;
//     return () => {
//         return ++count
//     }
// }
//
// const counter22 = counter()
//
// console.log(counter22()) // 1 or 2
// console.log(counter22()) // 2 or 3

// _____________________________________________________________________________________________________________________

// const thunkCreator = (id) => {
//     const thunk = (dispatch, state) => {
//         console.log(fetch(`https://google.com/${id}`))
//     }
//     return thunk
// }
//
// const thunk1 = thunkCreator(1)
// const thunk2 = thunkCreator(2)
//
// thunk1()

// _____________________________________________________________________________________________________________________

// Карирование

// const sum = (a) => (b) => (c) => a + b + c;

// function sum (a) {
//     return function(b = 0) {
//         return function(c = 0) {
//             return a + b + c
//         }
//     }
// }
// console.log(sum(1)()()) // 1

// Рекурсия

// function a () {
//     b(c())
// }
// function b () {}
// function c () {}
//
// a() формируется стэк вызовов функция а не может завершить выполнение пока не выполнится функция b
// функция b не может завершить выполнение пока не выполнится функция c
// функция c может завершить выполнение и после завершения функция c удаляется из стека
// и теперь функция b может выполниться and b выполняется после выполнения функции b выполняется функция a
// и после этого очищается стэк

// // ___________________________________Пример рекурсии с возведением в степень___________________________________________
//
// const pow = (x, n) => {
//     if (n === 1) {
//         return x
//     } else {
//         return x * pow(x, n - 1)
//     }
// }
//
// console.log(pow(3, 3)) // 27

// самый главный нюанс рекурсии что у нас должно быть выполнено условие выхода из рекурсии чтобы
// рекурсия не вошла в бесконечный цикл и не переполнился стэк вызовов ()
// когда if (n === 1) {} - нет смысла этой функции вызывать саму себя потому что степени меньше 1 не может быть
/*
const pow = (x, n) => {
    if (n === 1) {
        return x
    } else {
        return x * pow()
    }
} - функция может вызвать себя так как она найдет сама себя по замыканию в своей же lexical environment
но в момент вызова мы должны уменьшить n на шаг рекурсии pow(x, n - 1)
 */

/*
LE создается в момент выполнения функции
если данные из функции кто-то продолжает использовать после ее вызова то функция после отработки не будет удаляться
сборщиком мусора

2 главные фишки замыкания
способность функции выйти по ссылке своего лексического окружения в лексическое окружение родителя для поиска отсутствующего значения
не удаление из лексического окружения переменных с значениями в случае если какая-либо сущность извне ссылается на данные из
лексического окружения этой функции
 */


// _________________________________Пример замыкания____________________________________________________________________

// const counter = () => { // {count: 2, this, some}
//
//     let count = 1
//
//     return () => { // {this, some}
//         console.log(++count)
//     }
// }
//
// let counter_1 = counter()
// let counter_2 = counter()
//
// counter_1() // count = 2
// counter_1()
//
// counter_2()
// counter_2()



// ___________________________________Пример рекурсии с возведением в степень___________________________________________

/*
// стэк вызова

 */


const step = (x, n) => {
    if (n === 1) { // условие выхода
        return x
    } else {
        return 27 // шаг рекурсии
    }
}

console.log(step(3, 3)) // 27

console.log(typeof null)