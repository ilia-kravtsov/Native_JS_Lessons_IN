/*
    Интерпретатор JS может работать не со всеми типами данных а только с определенными типами данных

    в JS существует две большие группы типов данных:

        Примитивы:
        string number boolean null undefined NaN (infinity -infinity symbol)

        Объекты:
        array object function

    В чём разнцица:

    1. объекты имеют более сложную структуру, а именно, в объектах могут находиться как примитивы так и другие объекты
    2. объекты имеют ссылочный тип данных
    3. объекты имеют свойства и методы

    Есть ситуации когда примитивы ведут себя подобно объектам
        например: у примитива string мы можем вызвать метод slice()
        в этот момент на месте string создается объект
        одним из свойств этого объекта становится исходная строка
        после этого метод slice уже вызывается у этого появившегося объекта
        slice отрабатывает объект разрушается а string остается с изменениями от slice

        У примтива нельзя вызвать метод который используется для объектов
        Просто в некоторых случаях на месте примитива создается специальная объект-обёртка
        которая уже ведет себя как объект и результат поведения которой отражается на примитиве

    Обратим внимание на пункт 2 - ссылочный тип данных именно она и объединяет array object function
    в группу объекты.
        Array - разновидность объекта (некое ответвление, но все построены на одной объектной платформе)
        Function - разновидность объекта (некое ответвление, но все построены на одной объектной платформе)
    Если у нас есть переменная которой присваивается значение примтива строки:

    let variable_1 = 'killian'

    И есть вторая перемнная в которую мы кладем значение первой переменной

    let variable_2 = variable_1

    Далее, если мы переприсвоим значение variable_2

    variable_2 = null

    Вопрос: изменится ли значение variable_1 после этого изменения
    Ответ: нет, потому что когда мы создали через let variable_2 мы создали новую ячейку в памяти и новую ссылку на нее
    а уже значение взяли по старой ссылке variable_1

    console.log(variable_2) // null
    console.log(variable_1) // killian

    ***

    Проделаем аналогичную операцию с объектом

    const user = {
        name: 'Bob',
        age: 34,
    }

     const object_2 = object_1
     object_2.name = 'Alex'

     Вопрос: изменится ли значение object_1 после этого изменения
     Ответ: Да, console.log(object_1) // {name: 'Alex', age: 34}
     Потому что объект имеет ссылочный тип данных а это значит что так как object_2 было присвоено значение без {}
     литерала объекта, то создания нового объекта не произошло, а это значит что все изменения
     которые происходят в object_2 будут происходить и в object_1

     Более подробное объяснение:

     {
        name: 'Bob',
        age: 34,
     } - это не объект, это литерал объекта, команда, набор печатных символов, выполнение интерпретатором JS
     которой приведет к созданию объекта в оперативной памяти браузера

     То есть сам объект мы не видим в {} этот момент мы даем команду на создание литерала объекта

     В JS организован следующий порядок хранения объектов:
        в Оперативной памяти при получении команды на создание объекта создается ячейка для этого объекта
        под условным номером #123 и внутри этой ячейки будет создан объект
        Если мы создадим переменную let a = {} то после ее создания так ка мы указываем литерал
        в оперативной памяти создастся отдельная ячейка с условным номером #123
        То есть в переменную a запишется номер ячейки памяти #123 в которой хранится наш объект
        То есть не сам объект, а всего лишь его номер, то есть ссылка на этот объект
        как документы на собственность кв а не сама кв
        Таким образом в той ячейке памяти которая получила наименование a
        у нас будет лежать не значение объекта, а ссылка #123 на другую ячейки памяти
        Поэтому объекты и называют ссылочным типом данных
        То есть имя самого объекта мы не знаем оно равно условному #123
        а уже переменная let a хранит в себе всего лишь этот номер #123 то есть

        let a = {} === let a = {#123}, а оперативной памяти есть ячейка #123 {name: 'alex', age: '23'}

        Это сделано потому что передавать объект целиком - это ресурсно затратно, ссылку передавать проще

     Поэтому у нас в переменную object_1 записался номер ячейки памяти, предположим это #123

     let object_1 = {#123} =
     let object_2 = object_1 = {#123}

     Далее когда мы создали переменную object_2 мы присвоили переменной object_2 значение переменной object_1
     а это значение является ссылкой на объект #123
     Ссылки передавать удобнее чем заниматься дублированием и перемещением данных находящихся в объекте

     Поэтому

     const object_2 = object_1 - это новая ссылка на ту же ячейку памяти в которой лежит тот самый один объект

     Обращаем внимание на то что при создании object_2 нигде нет литерала объекта то есть не происходит создания нового
     объекта

     2 Варианта создания нового объекта

     1. new Object()
     2. {} - литерал объекта

     Поэтому когда мы:

     const object_2 = object_1 - получаем новую ссылку на тот же объект

     и меняем ему одно из свойств

     object_2.name = 'Alex'

     То по любой ссылке мы увидим уже изменившийся объект, то есть

     console.log(object_1) // {name: 'Alex', age: 34}
     console.log(object_2) // {name: 'Alex', age: 34}

     Поэтому объекты и называются ссылочным типом данных и это имеет отношение и к массивам и к объектам и к функциям

     ***

     const object_1 = {
        name: 'Bob',
        age: 34,
     }

     const object_2 = object_1
     object_2.name = 'Alex'

     console.log(object_1) // {name: 'Alex', age: 34}
     console.log(object_2) // {name: 'Alex', age: 34}

     ***

     Поэтому с данными нужно работать аккуратно, иначе могут произойти несанкционированные изменения
     которые отразятся на другой части кода
*/

    let variable_1 = 'killian'
    let variable_2 = variable_1
    variable_2 = null

    console.log(variable_2) // null
    console.log(variable_1) // killian

    const object_1 = {
        name: 'Bob',
        age: 34,
    }

    const object_2 = object_1
    object_2.name = 'Alex'

    console.log(object_1) // {name: 'Alex', age: 34}
    console.log(object_2) // {name: 'Alex', age: 34}

/*
                                  Conception of immutable work with data

    Концепция говорит нам о том что с данными нужно работать immutable то есть не изменяя исходные данные
    Концепция заключается в том что мы делаем копию данных над которыми хотим работать
    те изменения которые мы хотели внести в данные мы внесем в эту копию
    А исходные объект при этом остается не изменным
    А затем в дальнейшем использовать эту копию

    How it looks in the code:

    Сначала нужно создать новый объект, достаточно пустого {}

    const copyObject = {}

    Так как при объявлении мы указали литерал объекта, значит в переменной copyObject лежит ссылка на новый объект
    Наличие {} - литерала объекта, говорит нам о том что произошло создание нового объекта, мы дали для этого
    инструкцию

    Добавляем новые значения в объект

    copyObject_1.name = object_1.name
    copyObject_1.age = object_1.age - мы получили новый объект с такими же парами ключ значение как и object_1

    Как убедиться что copyObject_1 - это новый объект
    Возьмем значение переменной object_1 (в нем лежит ссылка #123) и сравним его с переменной
    object_2 (где лежит так же ссылка #123) результат сравнения - true
    потому что эти переменные содержат ссылки на один и тот же объект

    console.log(object_1 === object_2) // true

    А если мы сравним object_1 с copyObject_1

    console.log(copyObject_1 === object_1) // false

    То увидим false потому что copyObject_1 присваивалось значение с помощью {} - что является
    командной (инструкцией) для создания новой ячейки памяти
    Поэтому даже если мы скопируем те же самые свойства и значения в copyObject_1 что и object_1
    то для js это будет два разных объекта, потому что эти данные из этих объектов будут находиться
    уже в разных ячейках памяти и переменные будут иметь разные ссылки, каждая на свои данные

    При этом для нас эти два объекта будут выглядеть одинаково

    copyObject_1.name = object_1.name
    copyObject_1.age = object_1.age

    Способ копирования всех пар ключ значение из одного объекта в другой выше - примитивный
    Потому что таких пар может быть много
    Можно перебрать все пары ключ значения с помощью цикла, есть метод objectCreate
    но лучше пользоваться спред оператором

    Создаем новый объект, и внутрь него помещаем содержимое объекта object_1

    const newObject = {...object_1}

    console.log(newObject) // {name: 'Alex', age: 34}

    const newObject = {...object_1} -> код справа аналогичен -> copyObject_1.name = object_1.name
                                                                copyObject_1.age = object_1.age

    То есть мы взяли новую обертку {} а содержимое вкладываем старое {...object_1}

    Такой же алгоритм если хотим сделать копию массива

    const array_1 = [1,2,3,4,5]
    const array_2 = [array_1]
    const array_3 = [...array_1]

    console.log(array_1) // [1, 2, 3, 4, 5]
    console.log(array_2) // [Array(5)] 0: (5) [1, 2, 3, 4, 5] length: 1
    console.log(array_3) // [1, 2, 3, 4, 5]

    1 Сначала ставим литерал [] - команда на создание нового массива (в этот момент в памяти создался новый массив)
    2 const array_3 = [...array_1] помещаем все значения массива внутрь нового массива

    В React мы будем работать со структурой данных immutable
    то есть мы будем делать копию в копию вносить изменения и передавать в библиотеку новую структуру данных

    Reactу легко определить пришли ли новые данные просто за счет сравнения
    console.log(copyObject_1 === object_1) чтобы понять нужно перерисовывать объект или нет
    React перерисовывает компоненту только тогда когда видит что ему пришел новый объект
    а новым объектом будет считаться тот который создавался с помощью своего литерала

    Если планируем вносить изменения в структуру данных то делаем копию объекта и только потом вносим
    и используем в дальнейшем уже данные из копии, а исходные данные - теряются

    // объект => создаем копию => вносим изменения в копию => используем копию

*/

    const copyObject_1 = {}

    copyObject_1.name = object_1.name
    copyObject_1.age = object_1.age

    console.log(object_1 === object_2) // true
    console.log(copyObject_1 === object_1) // false

    console.log(object_1) // {name: 'Alex', age: 34}
    console.log(copyObject_1) // {name: 'Alex', age: 34}

    const newObject = {...object_1}
    console.log(newObject) // {name: 'Alex', age: 34}

    const array_1 = [1,2,3,4,5]
    const array_3 = [...array_1]

    console.log(array_1) // [1, 2, 3, 4, 5]
    console.log(array_3) // [1, 2, 3, 4, 5]
    console.log(array_1 === array_3) // false - разные объекты
    console.log(array_1[0] === array_3[0]) // true - данные одинаковые

/*
                                                 Усложняем конструкцию объекта
    const students = [
        {name: 'Bob', age: 34},
        {name: 'Alex', age: 32}
    ]

    students[0] // {#234} - здесь лежит ссылка на объект {name: 'Bob', age: 34}
    students[1] // {#345} - здесь лежит ссылка на объект {name: 'Bob', age: 34}

    Теперь когда мы будем делать копию массива

    const copyStudents = [...students]

    Сделали копию, но содержимое массива students - это ссылки на объекты {#234} {#345}

    Итого

     const students = [
        {name: 'Bob', age: 34},
        {name: 'Alex', age: 32}
    ]

    const copyStudents = [...students]
    console.log(students === copyStudents) // false
    console.log(students[0] === copyStudents[0]) // true

    При сравнении элемента копии с элементом исходного массив будет true потому что и там и там одна же ссылка
    А при сравнении оберток объектов будет false потому что копия создавалась с помощью литерала массива []

    Когда интерпретатор JS сравнивает два массива он обнаруживает что в students лежит ссылка на 1 массив
    а в copyStudents лежит ссылка на другой массив - console.log(students === copyStudents) // false

    console.log(students[0] === copyStudents[0]) // true - А true получается потому что  м
*/

    const students = [
        {name: 'Bob', age: 34},
        {name: 'Alex', age: 32}
    ]

    students[0] // ссылка {#234} - {name: 'Bob', age: 34}
    students[1] // ссылка {#345} - {name: 'Bob', age: 34}

    const copyStudents = [...students]
    console.log(students === copyStudents) // false
    console.log(students[0] === copyStudents[0]) // true

/*
                                            Полная и поверхностная копия

    const copyStudents = [...students] - поверхностная копия shallow copy

    Как сделать глубокую копию объекта (сплошную копию объекта)

    _______________________________ Примитивный способ, (вручную) :

    1 действие, создаю литерал объекта, который дает команду на создание новой ячейки памяти
    то есть создаю новый массив

    let deepCopyStudents = []

    2 действие, в массиве было два объекта поэтому указываю их литералы, для создания соответствующих ячеек памяти

    let deepCopyStudents = [{}, {}]

    3 действие, помещаем содержимое из каждого объекта поэлементно

    let deepCopyStudents = [{...students[0]},{...students[1]}] - такая копия будет считаться глубокой

    Теперь мы имеем полностью новый массив и полностью новые объекты которые содержат в точности те данные
    которые были в исходном массиве и теперь любые сравнения дадут нам false

    console.log(deepCopyStudents === students) // false
    console.log(deepCopyStudents[0] === students[0]) // false

    _________________________________ Оптимальный способ, map

    map - наш любимый метод массива который возращает новый массив и позволяет работать с данными immutable

    Мы берем исходный массив и говорим что мы хотим его преобразовать. map - отображение, образ

    let deepCopyWithMap = students.map()

    map в качестве параметра принимает функцию callback
    а уже эта функция в качестве параметра будет принимать каждый элемент исходного массива students (s)
    и внутри этой функции мы должны описать что мы хотим получить вместо s
    то есть вместо каждого объекта массива students, вместо students мы хотим получить его копию
    map на выходе создает новый массив в который положит объект s после изменений
    в нашем случае это будет новый литерал объекта со значениями из students[0] и students[1]

    let deepCopyWithMap = students.map((s) => {
        return {...s}
    })

    Рефакторим

    let deepCopyWithMap = students.map(s => ({...s}))
    ({...s}) - в скобках потому что без них, функция callback будет воспринимать литерал объекта s
    как тело своей функции

    Для сложных структур данных структуру которых мы не знаем, используем библиотеки Axios Lodash или clone npm package
*/

    let deepCopyStudents = [{...students[0]},{...students[1]}]

    console.log(deepCopyStudents === students) // false так как создали новый объект(массив) с помощью []
    console.log(deepCopyStudents[0] === students[0]) // false так как создали новые объекты с помощью [{},{}]

    let deepCopyWithMap = students.map(s => ({...s}))

/*
                                                CRUD операции

    C (Create) - у нас есть исходный объект-массив students там было 2 студента, допустим нам нужно добавить студента,
                 для этого создаем новый массив [], в новый массив кладём элементы из students без изменений,
                 и в этот новый массив добавляем нового студента

                 let oldArray = [X,X]
                 let newArray = [X,X,Y] - здесь не нужна сплошная-глубокая копия,
                 Здесь мы делаем поверхностную копию в новом литерале и туда добавляем новый элемент

                 То есть проблема сплошного копирования в случае добавления сущности у нас не актуальна
    R (Read) - если хотим получить из элементов-объектов старого массива, новый массив но уже с измененным
               состоянием каждого элемента-объекта, например через props передать в компоненту данные
               и затем отрисовать их в JSX разметке

               let oldArray = [X,X]
               let newArray = [<X/>,<X/>]
               Это единственная ситуация когда мы будем создавать новый массив и каждый элемент исходного массива
               мы будем упаковывать в какой-то тег, то есть это единственный случай когда нам может понадобится
               преобразование массива deepCopy

               Пример в Todolist из массива объектов мы отрисовывали jsx разметку в виде li
               это и было сплошное преобразование за счет создания глубокой копии массива, только на выходе был массив
               jsx li элементов

   U (Update) - это значит что у кого-то из студентов произошли изменения 
*/